`Variadic functions` (функции с пременным количеством аргументов) - это функции , которые могут принимать переменное число аргументов . В программировании на C вариационная функция добавляет гибкости программе. Он принимает один фиксированный аргумент, а затем может быть передано любое количество аргументов. Вариативная функция состоит как минимум из одной фиксированной переменной и многоточия (…) в качестве последнего параметра.

```c
prototype
    
    int function_name(data_type variable_name, ...);
```
Доступ к значениям переданных аргументов можно получить через заголовочный файл с именем: #include <stdarg.h>


#### <stdarg.h> включает следующие методы:  
`va_list` - Тип, который используется для извлечения дополнительных параметров функции с переменным числом параметров;

`void va_start(va_list ap, paramN)` - Макрос инициализирует va_list для извлечения дополнительных аргументов, которые идут после переменной paramN (first argument of our variadic function). 
Параметр не должен быть объявлен как register, не может иметь тип массива или указателя на функцию;

`void va_end(va_list ap)` - Макрос необходим для нормального завершения работы функции, работает в паре с макросом va_start;

`void va_copy(va_list dest, va_list src)` - Макрос копирует src в dest. Поддерживается начиная со стандарта C++11);

Для упрощения работы с переменным количеством параметров неопределенных типов в языке Си в стандартом заголовочном 
файле stdarg.h определены специальные макрокоманды:
```c
va_start();  
va_arg();  
va_end();  
```
Все эти макросы используют специальный тип данных va_list, который также определен в stdarg.h и который позволяет 
обрабатывать нефиксированный набор параметров.

#### Макрос va_start имеет следующее определение:  
`void va_start(va_list param, последний_явный_параметр);`  
Первый параметр макроса - param связывает объект va_list с первым необязательным параметром. Для его определения 
в качестве второго параметра в макрос передается последний обязательный параметр функции. Таким образом, используя 
последний обязательный параметр, мы можем нацелить объект va_list на адрес первого необязательного параметра. 
То есть фактически va_list выступает в данной роли как указатель.

#### Макрос va_arg имеет следующее определение:  
`type va_arg(va_list param, type);`  
Этот макрос позволяет получить значение параметра типа type, а также переместить указатель va_list 
на следующий необязательный параметр.

#### Макрос va_end позволяет выйти из функции с переменным списком параметров. Она имеет следующее определение:  
`void va_end(va_list param);`  
В качестве параметра va_end принимает указатель va_start, который ранее был задействован в макросах va_start и va_arg.
```c
#include <stdio.h>
#include <stdarg.h>
 
int sum(int n, ...)
{
    int result = 0;
    va_list factor;                     // указатель va_list
    va_start(factor, n);                // устанавливаем указатель
    for(int i=0;i<n; i++)
    {
        result += va_arg(factor, int);  // получаем значение текущего параметра типа int
    }
    va_end(factor);                     // завершаем обработку параметров
    return result;
}
 
int main(void)
{   
    printf("%d \n", sum(4, 1, 2, 3, 4));
    printf("%d \n", sum(5, 12, 21, 13, 4, 5));
    return 0;
}
```
В функции sum() вначале определяется указатель va_list factor;  
Далее связываем этот указатель с первым необязательным параметром: va_start(factor, n);  
В цикле пробегаемся по всем необязательным параметрам и их значение прибавляем к переменной result: result += va_arg(factor, int);  
В конце завершаем обработку параметров: va_end(factor);  

Результат этой программы будет тот же, что и в предыдущем случае. Но здесь опять же нам надо передавать количество необязательных 
параметров в качестве первого параметра функции sum. И, кроме того, мы точно знаем, что необязательные параметры имеют тип int.
Но стоит отметить, что используемые нами функции ввода-вывода printf() и scanf() то же имеют неопределенное число параметров, 
но их типы также неопределены:

```c
int printf(const char* format, ...);
int scanf(const char* format, ...);
```
Для идентификации типов аргументов параметр format использует спецификаторы `%d`, `%c` и так далее. Например, определим собстенную функцию, 
которая будет выводит текст на экран, принимая параметры разных типов:

```c
#include <stdio.h>
#include <stdarg.h>
 
void display(char* format, ...)
{
    int d; 
    double f;
    va_list factor;                             // указатель на необязательный параметр
    va_start(factor, format);                   // устанавливаем указатель
     
    for(char *c = format;*c; c++)
    {
        if(*c!='%')
        {
            printf("%c", *c);
            continue;
        }
        switch(*++c)                            // если символ - %, то переходим к следующему символу
        {
            case 'd': 
                d = va_arg(factor, int);
                printf("%d", d);
                break;
            case 'f': 
                f = va_arg(factor, double);
                printf("%.2lf", f);
                break;
            default:
                printf("%c", *c);
        }
    }
    va_end(factor);
}
 
int main(void)
{   
    display("Count: %d \tPrice: %f", 24, 68.4);
    return 0;
}
```

Для упрощения примера здесь взяты только два спецификатора: d (для типа int) и f (для типа double).   
В самой функции display с помощью указателя char *c пробегаемся по всем символам переданной строки format, 
пока этот указатель не станет указывать на нулевой символ (*c!='\0'). Если символ не равен знаку %, 
то выводим этот символ. Иначе смотрим, какой символ идет после знака % - d или f. В зависимости от 
этого получаем либо объект int, либо объект double.

#### [HEX]
Для того, чтобы преобразовать число из десятичной системы счисления в шестнадцатеричную, необходимо выполнить следующие действия.

Делим десятичное число на 16 и записываем остаток от деления.
Результат деления вновь делим на 16 и опять записываем остаток.
Повторяем операцию до тех пор пока результат деления не будет равен нулю.
Запишем полученные остатки в обратном порядке и получим искомое число.

Переведем число 1000 в шестнадцатеричную систему:

```c
1000 / 16 = 62 (остаток 8)  
62 / 16 = 3 (остаток 14, в шестнадцатеричной системе – E)  
3 / 16 = 0 (остаток 3)  
Записываем остатки в обратном порядке, получаем результат: 3E8  
```

Вопросы:
1) Почему type unsigned int - это стандарт, для лонг используется lx

#### [CHAR]
Почему нужно использовать  int?

Потому что так говорит стандарт. Если вы передаете целочисленное значение с рангом преобразования меньше, чем у `int`(например char, boolили short) в функцию, принимающую переменное число аргументов, оно будет преобразовано в `int`. Предположительно, причина этого кроется в производительности, где было (и, по сути, часто и сейчас) лучше передавать значения, выровненные по границе машинного слова.
Для вариативной функции компилятор не знает типы параметров, соответствующих , .... По историческим причинам и для облегчения работы компилятора любые соответствующие аргументы более узких типов, чем `int`, повышаются до `int` или до `unsigned int`, а любые аргументы типа `float` повышаются до `double`. Вот почему `printf` используются одни и те же спецификаторы формата для аргументов `float` или `double`.

Таким образом, функция с переменным числом аргументов не может принимать аргументы типа `char`. Вы можете вызвать такую функцию с `char` аргументом, но она будет повышена до `int`.

(В ранних версиях C, до того, как были введены прототипы, все функции вели себя таким образом. Даже C11 допускает непрототипные объявления, в которых узкие аргументы повышаются до `int`, `unsigned int`, или `double`. Но, учитывая существование прототипов, на самом деле нет причин писать код, зависящий от таких повышений, за исключением особого случая функций с переменным числом аргументов.)

Из-за этого нет смысла использовать `va_arg() type char` в качестве аргумента типа.

Но язык не запрещает такой вызов `va_arg();` на самом деле в разделе описания стандарта `<stdarg.h>` не упоминается продвижение аргумента . Правило указано в разделе о вызовах функций, N1570 6.5.2.2 параграф 7:

Если выражение, обозначающее вызываемую функцию, имеет тип, который включает прототип, аргументы неявно преобразуются, как если бы путем присваивания, в типы соответствующих параметров, при этом тип каждого параметра принимается за неквалифицированную версию его объявленного тип. Обозначение с многоточием в деклараторе прототипа функции приводит к тому, что преобразование типа аргумента останавливается после последнего объявленного параметра. Продвижение аргументов по умолчанию выполняется для завершающих аргументов.

А в описании `va_arg()` макроса 7.16.1.1 сказано:

Если фактического следующего аргумента нет или если тип несовместим с типом фактического следующего аргумента (как продвигается в соответствии с продвижением аргумента по умолчанию), поведение не определено, за исключением следующих случаев...

«Продвижение аргументов по умолчанию» преобразует узкие аргументы в `int`, `unsigned int` или `double`. (Аргумент беззнакового целочисленного типа, максимальное значение которого превышает `INT_MAX`, будет повышен до `unsigned int`. Теоретически `char` такое поведение возможно, но только в очень необычной реализации.)

